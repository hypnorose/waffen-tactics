        # Apply skill effect (basic implementation)
        effect = skill['effect']
        if effect.get('type') == 'damage':
            # Deal damage to target using canonical emitter (mutates target.hp)
            skill_damage = int(effect.get('amount', 0))
            try:
                from .event_canonicalizer import emit_damage
                dmg_payload = emit_damage(None, caster, target, raw_damage=skill_damage, damage_type=effect.get('damage_type', 'physical'), side=side, timestamp=time, cause='skill', emit_event=False)
                # Keep hp_list in sync with authoritative target.hp
                try:
                    target_hp_list[target_idx] = int(dmg_payload.get('post_hp', getattr(target, 'hp', 0)))
                except Exception:
                    target_hp_list[target_idx] = int(getattr(target, 'hp', 0))
            except Exception:
                # Fallback: naive hp list mutation
                try:
                    target_hp_list[target_idx] = max(0, int(target_hp_list[target_idx] - skill_damage))
                except Exception:
                    pass
            log.append(f"[{time:.2f}s] {skill.get('name', getattr(skill, 'name', '<skill>'))} deals {skill_damage} damage to {target.name}")

            if event_callback:
                event_callback('skill_cast', {
                    'caster_id': getattr(caster, 'id', None),
                    'caster_name': getattr(caster, 'name', None),
                    'skill_name': skill.get('name', getattr(skill, 'name', None)),
                    'target_id': getattr(target, 'id', None),
                    'target_name': getattr(target, 'name', None),
                    'damage': skill_damage,
                    'target_hp': target_hp_list[target_idx],
                    'target_max_hp': getattr(target, 'max_hp', None),
                    'side': side,
                    'timestamp': time,
                    'message': f"{getattr(caster, 'name', None)} casts {skill.get('name', getattr(skill, 'name', None))}!"
                })

        # Check if target died from skill
        if target_hp_list[target_idx] <= 0:
            # Use _process_unit_death to handle trait effects properly
            self._process_unit_death(caster, [target], target_hp_list, [caster], [caster.max_hp], target_idx, time, log, event_callback, side)