"""
Skill Executor - Executes skills during combat
"""
import asyncio
import time
import random
from typing import List, Any, Dict, Optional
from waffen_tactics.models.skill import Skill, Effect, SkillExecutionContext, EffectType, TargetType
from waffen_tactics.services.effects import get_effect_handler


class SkillExecutionError(Exception):
    """Raised when skill execution fails"""
    pass


class SkillExecutor:
    """Executes skills and manages their effects"""

    def __init__(self):
        self.effect_handlers = {}

    def execute_skill(self, skill: Skill, context: SkillExecutionContext) -> List[Dict[str, Any]]:
        """
        Execute a skill and return list of events generated

        Args:
            skill: The skill to execute
            context: Execution context with caster and teams

        Returns:
            List of combat events generated by the skill
        """
        events = []

        try:
            # Determine required mana to cast.
            # Prefer explicit skill.mana_cost if present (back-compat for tests/data),
            # otherwise use caster's max_mana as the single source of truth.
            required_mana = None
            if getattr(skill, 'mana_cost', None) is not None:
                required_mana = skill.mana_cost
            else:
                required_mana = getattr(context.caster, 'max_mana', None) or getattr(context.caster, 'stats', {}).get('max_mana', None)
            if required_mana is None:
                # Fallback to 100 if somehow missing
                required_mana = 100

            # Check if caster has enough mana
            if context.caster.mana < required_mana:
                raise SkillExecutionError(f"Insufficient mana: {context.caster.mana} < {required_mana}")

            # Deduct mana (consume full bar)
            context.caster.mana = max(0, context.caster.mana - required_mana)
            # Determine side
            side = 'team_a' if any(u.id == context.caster.id for u in context.team_a) else 'team_b'
            events.append(('mana_update', {
                'unit_id': context.caster.id,
                'unit_name': context.caster.name,
                'current_mana': context.caster.mana,
                'max_mana': context.caster.max_mana,
                'side': side,
                'timestamp': context.combat_time
            }))

            # Emit skill_cast first (meta/display) then execute effects so
            # the UI shows the caster using the skill before the effect lines.
            skill_delay = 0.2  # Fixed delay after last attack
            events.append(('skill_cast', {
                'caster_id': context.caster.id,
                'caster_name': context.caster.name,
                'skill_name': skill.name,
                'target_id': None,
                'target_name': None,
                'damage': None,
                'timestamp': context.combat_time + skill_delay
            }))

            # Execute effects sequentially (effects come after skill_cast)
            for effect in skill.effects:
                effect_events = self._execute_effect(effect, context)
                events.extend(effect_events)

        except Exception as e:
            raise SkillExecutionError(f"Failed to execute skill {skill.name}: {e}")

        return events

    def _execute_effect(self, effect: Effect, context: SkillExecutionContext) -> List[Dict[str, Any]]:
        """Execute a single effect"""
        events = []

        # Get targets for this effect
        targets = self._get_targets(effect.target, context)

        # Get effect handler
        handler = get_effect_handler(effect.type)
        if not handler:
            raise SkillExecutionError(f"No handler found for effect type: {effect.type}")

        # Execute effect on targets
        for target in targets:
            try:
                # Call the handler - it may be sync or async
                result = handler.execute(effect, context, target)
                # If a coroutine is returned, run it to completion
                if asyncio.iscoroutine(result):
                    loop = asyncio.new_event_loop()
                    try:
                        effect_events = loop.run_until_complete(result)
                    finally:
                        loop.close()
                else:
                    effect_events = result

                # Extend events if the handler returned a list
                if effect_events:
                    events.extend(effect_events)
            except Exception as e:
                # Log error but continue with other targets
                print(f"Error executing effect {effect.type} on target {getattr(target, 'id', '<unknown>')}: {e}")
                continue

        return events

    def _get_targets(self, target_type: TargetType, context: SkillExecutionContext) -> List[Any]:
        """Get list of targets for an effect"""
        caster = context.caster
        caster_team = context.caster_team
        enemy_team = context.enemy_team

        if target_type == TargetType.SELF:
            return [caster]

        elif target_type == TargetType.SINGLE_ENEMY:
            # Random enemy - prefer alive targets but fall back to any enemy
            alive_enemies = [u for u in enemy_team if getattr(u, 'hp', 0) > 0]
            candidates = alive_enemies if alive_enemies else list(enemy_team)

            # If there truly are no enemies at all, return empty
            if not candidates:
                return []

            # Use random_seed for deterministic behavior if provided
            if context.random_seed is not None:
                random.seed(context.random_seed)
            return [random.choice(candidates)]

        elif target_type == TargetType.SINGLE_ENEMY_PERSISTENT:
            # Same enemy for all effects in this skill execution
            if context.persistent_target is not None:
                # Check if target is still alive
                if context.persistent_target.hp > 0:
                    return [context.persistent_target]
                else:
                    # Target died, clear it
                    context.persistent_target = None
            
            # Choose new persistent target
            alive_enemies = [u for u in enemy_team if u.hp > 0]
            if not alive_enemies:
                return []
            
            # Use random_seed for deterministic behavior if provided
            if context.random_seed is not None:
                random.seed(context.random_seed)
            context.persistent_target = random.choice(alive_enemies)
            return [context.persistent_target]

        elif target_type == TargetType.ENEMY_TEAM:
            return [u for u in enemy_team if u.hp > 0]

        elif target_type == TargetType.ENEMY_FRONT:
            # Front line: first 3 units or fewer
            alive_enemies = [u for u in enemy_team if u.hp > 0]
            return alive_enemies[:3]

        elif target_type == TargetType.ALLY_TEAM:
            return [u for u in caster_team if u.hp > 0]

        elif target_type == TargetType.ALLY_FRONT:
            # Front line: first 3 units or fewer
            alive_allies = [u for u in caster_team if u.hp > 0]
            return alive_allies[:3]

        else:
            return []


# Global executor instance
skill_executor = SkillExecutor()