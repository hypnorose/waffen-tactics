"""
Animation System Types and Interfaces

Core types for the modular animation system that supports extensible
animation types with proper synchronization between start and effect events.
"""

from typing import Dict, Any, Optional, Protocol, Union
from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum


class AnimationType(Enum):
    """Built-in animation types"""
    PROJECTILE = "projectile"
    SCREEN_EFFECT = "screen_effect"
    UNIT_ANIMATION = "unit_animation"
    CUSTOM = "custom"


@dataclass
class AnimationConfig:
    """Configuration for a specific animation"""
    id: str
    type: AnimationType
    duration: float = 0.3  # seconds
    renderer_config: Dict[str, Any] = None

    def __post_init__(self):
        if self.renderer_config is None:
            self.renderer_config = {}


@dataclass
class AnimationTrigger:
    """Data passed to renderers when animation starts"""
    animation_id: str
    attacker_id: Optional[str] = None
    target_id: Optional[str] = None
    skill_name: Optional[str] = None
    timestamp: float = 0.0
    custom_data: Dict[str, Any] = None

    def __post_init__(self):
        if self.custom_data is None:
            self.custom_data = {}


class AnimationRenderer(Protocol):
    """Protocol for animation renderers"""

    @property
    def animation_type(self) -> AnimationType:
        """The type of animation this renderer handles"""
        ...

    def can_render(self, config: AnimationConfig) -> bool:
        """Check if this renderer can handle the given config"""
        ...

    def render(self, trigger: AnimationTrigger, config: AnimationConfig) -> None:
        """Render the animation. Should be non-blocking."""
        ...

    def cleanup(self) -> None:
        """Clean up any resources"""
        ...


@dataclass
class AnimationEvent:
    """Event data for animation synchronization"""
    type: str = "animation_start"
    animation_id: str = ""
    attacker_id: Optional[str] = None
    target_id: Optional[str] = None
    skill_name: Optional[str] = None
    duration: float = 0.3
    timestamp: float = 0.0
    seq: Optional[int] = None
    event_id: str = ""

    @classmethod
    def from_trigger(cls, trigger: AnimationTrigger, seq: Optional[int] = None) -> 'AnimationEvent':
        """Create an AnimationEvent from an AnimationTrigger"""
        import uuid
        return cls(
            animation_id=trigger.animation_id,
            attacker_id=trigger.attacker_id,
            target_id=trigger.target_id,
            skill_name=trigger.skill_name,
            timestamp=trigger.timestamp,
            seq=seq,
            event_id=str(uuid.uuid4())
        )


class AnimationRegistry:
    """Central registry for animation configurations and renderers"""

    def __init__(self):
        self._configs: Dict[str, AnimationConfig] = {}
        self._renderers: Dict[AnimationType, AnimationRenderer] = {}

    def register_config(self, config: AnimationConfig) -> None:
        """Register an animation configuration"""
        self._configs[config.id] = config

    def get_config(self, animation_id: str) -> Optional[AnimationConfig]:
        """Get animation config by ID"""
        return self._configs.get(animation_id)

    def register_renderer(self, renderer: AnimationRenderer) -> None:
        """Register an animation renderer"""
        self._renderers[renderer.animation_type] = renderer

    def get_renderer(self, animation_type: AnimationType) -> Optional[AnimationRenderer]:
        """Get renderer for animation type"""
        return self._renderers.get(animation_type)

    def trigger_animation(self, trigger: AnimationTrigger) -> bool:
        """Trigger an animation if config and renderer exist"""
        config = self.get_config(trigger.animation_id)
        if not config:
            return False

        renderer = self.get_renderer(config.type)
        if not renderer or not renderer.can_render(config):
            return False

        renderer.render(trigger, config)
        return True

    def get_registered_animation_ids(self) -> list[str]:
        """Get all registered animation IDs"""
        return list(self._configs.keys())ffen_tactics/animation/types.py        return list(self._configs.keys())
