import { useState, useEffect, useRef } from 'react'
import { PlayerState } from '../store/gameStore'
import { useAuthStore } from '../store/authStore'
import { useCombatSSEBuffer } from './combat/useCombatSSEBuffer'
import { computeDelayMs } from './combat/replayTiming'
import { applyCombatEvent } from './combat/applyEvent'
import { compareUnits } from './combat/desync'
import { useCombatAnimations } from './combat/useCombatAnimations'
import { CombatState, CombatEvent, DesyncEntry } from './combat/types'

interface UseCombatOverlayLogicProps {
  onClose: (newState?: PlayerState) => void
  logEndRef: MutableRefObject<HTMLDivElement | null>
}

export function useCombatOverlayLogic({ onClose, logEndRef }: UseCombatOverlayLogicProps) {
  const { token } = useAuthStore()
  const { bufferedEvents, isBufferedComplete } = useCombatSSEBuffer(token)
  const [playhead, setPlayhead] = useState(0)
  const [combatState, setCombatState] = useState<CombatState>({
    playerUnits: [],
    opponentUnits: [],
    combatLog: [],
    isFinished: false,
    victory: null,
    finalState: null,
    synergies: {},
    traits: [],
    opponentInfo: null,
    regenMap: {},
    simTime: 0
  })
  const [hoveredTrait, setHoveredTrait] = useState<string | null>(null)
  const [showLog, setShowLog] = useState(false)
  const [combatSpeed, setCombatSpeed] = useState(() => {
    const saved = localStorage.getItem('combatSpeed')
    return saved ? parseFloat(saved) : 1
  })
  const [desyncLogs, setDesyncLogs] = useState<DesyncEntry[]>([])
  const [overwriteSnapshots, setOverwriteSnapshots] = useState<boolean>(() => {
    try {
      const v = localStorage.getItem('combat.overwriteSnapshots')
      return v === null ? true : v === 'true'
    } catch (err) {
      return true
    }
  })
  const [storedGoldBreakdown, setStoredGoldBreakdown] = useState<{ base: number, interest: number, milestone: number, win_bonus: number, total: number } | null>(null)
  const [displayedGoldBreakdown, setDisplayedGoldBreakdown] = useState<{ base: number, interest: number, milestone: number, win_bonus: number, total: number } | null>(null)

  const { attackingUnits, targetUnits, animatingUnits, attackDurations, triggerAttackAnimation, triggerTargetFlash } = useCombatAnimations()

  const pushDesync = (entry: DesyncEntry) => {
    setDesyncLogs(prev => [entry, ...prev].slice(0, 200))
  }

  const clearDesyncLogs = () => setDesyncLogs([])

  const exportDesyncJSON = () => {
    try {
      return JSON.stringify(desyncLogs, null, 2)
    } catch (err) {
      console.error('Failed to stringify desyncLogs', err)
      return '[]'
    }
  }

  // Persist settings
  useEffect(() => {
    try {
      localStorage.setItem('combat.overwriteSnapshots', overwriteSnapshots ? 'true' : 'false')
    } catch (err) {}
  }, [overwriteSnapshots])

  useEffect(() => {
    try {
      localStorage.setItem('combatSpeed', combatSpeed.toString())
    } catch (err) {}
  }, [combatSpeed])

  // Replay loop
  useEffect(() => {
    if (!isBufferedComplete || playhead >= bufferedEvents.length) return

    const event = bufferedEvents[playhead]
    console.log('Applying event:', event.type, 'seq:', event.seq, 'playhead:', playhead)

    // Apply event
    const newState = applyCombatEvent(combatState, event, { overwriteSnapshots, simTime: combatState.simTime })
    setCombatState(newState)

    // Trigger animations
    if (event.type === 'unit_attack' && event.attacker_id && event.target_id) {
      const allUnits = [...newState.playerUnits, ...newState.opponentUnits]
      triggerAttackAnimation(event.attacker_id, event.target_id, combatSpeed, allUnits)
    } else if (event.type === 'damage_over_time_tick' && event.unit_id) {
      triggerTargetFlash(event.unit_id, combatSpeed)
    }

    // Compare with server if game_state present
    if (event.game_state) {
      const playerDesyncs = compareUnits(newState.playerUnits, event.game_state.player_units, 'player', event)
      const oppDesyncs = compareUnits(newState.opponentUnits, event.game_state.opponent_units, 'opponent', event)
      playerDesyncs.forEach(pushDesync)
      oppDesyncs.forEach(pushDesync)
    }

    // Schedule next
    const nextEvent = bufferedEvents[playhead + 1]
    if (nextEvent) {
      const delay = computeDelayMs(event, nextEvent, combatSpeed, 1.25)
      setTimeout(() => setPlayhead(playhead + 1), delay)
    } else {
      // Finished
      setCombatState(prev => ({ ...prev, isFinished: true }))
    }
  }, [isBufferedComplete, bufferedEvents, playhead, combatState, combatSpeed, overwriteSnapshots, triggerAttackAnimation, triggerTargetFlash])

  // Start replay when buffered
  useEffect(() => {
    if (isBufferedComplete && bufferedEvents.length > 0) {
      setPlayhead(0)
    }
  }, [isBufferedComplete, bufferedEvents.length])

  // Regen and effect cleanup
  useEffect(() => {
    const t = setInterval(() => {
      const now = Date.now()
      setCombatState(prev => {
        let changed = false
        const newRegenMap = { ...prev.regenMap }
        for (const k of Object.keys(newRegenMap)) {
          if (newRegenMap[k].expiresAt <= now) {
            delete newRegenMap[k]
            changed = true
          }
        }
        if (!changed) return prev

        return { ...prev, regenMap: newRegenMap }
      })

      // Cleanup expired effects
      setCombatState(prev => {
        let changed = false
        const newPlayerUnits = prev.playerUnits.map(u => {
          if (!u.effects || u.effects.length === 0) return u
          const remaining = u.effects.filter((e: any) => !e.expiresAt || e.expiresAt > now)
          if (remaining.length !== u.effects.length) {
            changed = true
            return { ...u, effects: remaining }
          }
          return u
        })
        const newOpponentUnits = prev.opponentUnits.map(u => {
          if (!u.effects || u.effects.length === 0) return u
          const remaining = u.effects.filter((e: any) => !e.expiresAt || e.expiresAt > now)
          if (remaining.length !== u.effects.length) {
            changed = true
            return { ...u, effects: remaining }
          }
          return u
        })
        if (changed) {
          return { ...prev, playerUnits: newPlayerUnits, opponentUnits: newOpponentUnits }
        }
        return prev
      })
    }, 500)
    return () => clearInterval(t)
  }, [])

  useEffect(() => { logEndRef.current?.scrollIntoView({ behavior: 'smooth' }) }, [combatState.combatLog])

  const handleClose = () => onClose(combatState.finalState || undefined)
  const handleGoldDismiss = () => { setDisplayedGoldBreakdown(null); setStoredGoldBreakdown(null); handleClose() }

  return {
    playerUnits: combatState.playerUnits,
    opponentUnits: combatState.opponentUnits,
    combatLog: combatState.combatLog,
    isFinished: combatState.isFinished,
    victory: combatState.victory,
    finalState: combatState.finalState,
    synergies: combatState.synergies,
    traits: combatState.traits,
    hoveredTrait,
    setHoveredTrait,
    opponentInfo: combatState.opponentInfo,
    showLog,
    setShowLog,
    attackingUnits,
    targetUnits,
    attackDurations,
    animatingUnits,
    combatSpeed,
    setCombatSpeed,
    regenMap: combatState.regenMap,
    storedGoldBreakdown,
    displayedGoldBreakdown,
    setDisplayedGoldBreakdown,
    setStoredGoldBreakdown,
    handleClose,
    handleGoldDismiss,
    desyncLogs,
    clearDesyncLogs,
    exportDesyncJSON,
    overwriteSnapshots,
    setOverwriteSnapshots
  }
}



import { MutableRefObject } from 'react'

interface UseCombatOverlayLogicProps {
  onClose: (newState?: PlayerState) => void
  logEndRef: MutableRefObject<HTMLDivElement | null>
}

export function useCombatOverlayLogic({ onClose, logEndRef }: UseCombatOverlayLogicProps) {
  const { token } = useAuthStore()
  const [playerUnits, setPlayerUnits] = useState<Unit[]>([])
  const [opponentUnits, setOpponentUnits] = useState<Unit[]>([])
  const [combatLog, setCombatLog] = useState<string[]>([])
  const [isFinished, setIsFinished] = useState(false)
  const [victory, setVictory] = useState<boolean | null>(null) // null = ongoing, true = win, false = lose
  const [finalState, setFinalState] = useState<PlayerState | null>(null)
  const [synergies, setSynergies] = useState<Record<string, { count: number, tier: number }>>({})
  const [traits, setTraits] = useState<TraitDefinition[]>([])
  const [hoveredTrait, setHoveredTrait] = useState<string | null>(null)
  const [opponentInfo, setOpponentInfo] = useState<{ name: string, wins: number, level: number } | null>(null)
  const [showLog, setShowLog] = useState(false)
  // Support multiple concurrent attack/target highlights so events don't cancel each other
  const [attackingUnits, setAttackingUnits] = useState<string[]>([])
  const [targetUnits, setTargetUnits] = useState<string[]>([])
  const [combatSpeed, setCombatSpeed] = useState(() => {
    const saved = localStorage.getItem('combatSpeed')
    return saved ? parseFloat(saved) : 1
  })
  const [eventQueue, setEventQueue] = useState<CombatEvent[]>([])
  const [animatingUnits, setAnimatingUnits] = useState<string[]>([])
  const [attackDurations, setAttackDurations] = useState<Record<string, number>>({})
  // Make animations slightly slower by default but scale with combatSpeed
  // animationScale > 1 slows animations; follow-up divides by combatSpeed
  const animationScale = 1.25
  const [regenMap, setRegenMap] = useState<Record<string, { amount_per_sec: number; total_amount: number; expiresAt: number }>>({})
  // Effects will be attached to unit objects as `effects: EffectSummary[]`
  const [isPlaying, setIsPlaying] = useState(false)
  const [desyncLogs, setDesyncLogs] = useState<DesyncEntry[]>([])
  const [overwriteSnapshots, setOverwriteSnapshots] = useState<boolean>(() => {
    try {
      const v = localStorage.getItem('combat.overwriteSnapshots')
      return v === null ? true : v === 'true'
    } catch (err) {
      return true
    }
  })
  const [storedGoldBreakdown, setStoredGoldBreakdown] = useState<{ base: number, interest: number, milestone: number, win_bonus: number, total: number } | null>(null)
  const [displayedGoldBreakdown, setDisplayedGoldBreakdown] = useState<{ base: number, interest: number, milestone: number, win_bonus: number, total: number } | null>(null)
  // Fix: lastTimestampRef must be at top level, not inside useEffect
  const lastTimestampRef = useRef<number | null>(null)
  const processingRef = useRef(false)
  const playerUnitsRef = useRef<Unit[]>([])
  const opponentUnitsRef = useRef<Unit[]>([])
  const activeTimeoutsRef = useRef<number[]>([])

  // Keep refs in sync with state
  useEffect(() => {
    playerUnitsRef.current = playerUnits
  }, [playerUnits])
  useEffect(() => {
    opponentUnitsRef.current = opponentUnits
  }, [opponentUnits])

  const pushDesync = (entry: DesyncEntry) => {
    setDesyncLogs(prev => [entry, ...prev].slice(0, 200))
    // Also keep console visibility
    console.warn('[DESYNC]', entry.unit_id, entry)
  }

  const clearDesyncLogs = () => setDesyncLogs([])

  const exportDesyncJSON = () => {
    try {
      return JSON.stringify(desyncLogs, null, 2)
    } catch (err) {
      console.error('Failed to stringify desyncLogs', err)
      return '[]'
    }
  }

  const compareUnits = (localUnits: Unit[], serverUnits: any[], side: string, event: CombatEvent) => {
    const localMap = new Map(localUnits.map(u => [u.id, {
      id: u.id,
      name: u.name,
      hp: u.hp,
      max_hp: u.max_hp,
      attack: u.attack,
      defense: u.defense ?? 0,
      attack_speed: u.buffed_stats?.attack_speed ?? 1,
      star_level: u.star_level,
      position: u.position ?? 'front',
      effects: u.effects ?? [],
      current_mana: u.current_mana ?? 0,
      max_mana: u.max_mana ?? 100,
      shield: u.shield ?? 0,
      buffed_stats: u.buffed_stats ?? {}
    }]))
    for (const su of serverUnits) {
      const lu = localMap.get(su.id)
      if (!lu) continue
      const diff: Record<string, { ui: any, server: any }> = {}
      const fields = ['hp', 'max_hp', 'attack', 'defense', 'attack_speed', 'current_mana', 'max_mana', 'shield']
      for (const f of fields) {
        if ((lu as any)[f] !== su[f]) diff[f] = { ui: (lu as any)[f], server: su[f] }
      }
      if (JSON.stringify(lu.buffed_stats) !== JSON.stringify(su.buffed_stats)) diff['buffed_stats'] = { ui: lu.buffed_stats, server: su.buffed_stats }
      if (JSON.stringify(lu.effects) !== JSON.stringify(su.effects)) diff['effects'] = { ui: lu.effects, server: su.effects }
      if (Object.keys(diff).length > 0) {
        if (diff.hp || diff.effects) console.log('Desync for', su.id, su.name, 'diff:', diff)
        pushDesync({ unit_id: su.id, unit_name: su.name, seq: event.seq, timestamp: event.timestamp, diff, pending_events: [], note: `event ${event.type} diff (${side})` })
      }
    }
  }

  // persist toggle to localStorage so it is global-ish across the app
  useEffect(() => {
    try {
      localStorage.setItem('combat.overwriteSnapshots', overwriteSnapshots ? 'true' : 'false')
    } catch (err) {
      // ignore
    }
  }, [overwriteSnapshots])

  const eventSourceRef = useRef<EventSource | null>(null)

  useEffect(() => {
    // Prevent multiple EventSources
    if (eventSourceRef.current) {
      return
    }

    if (!token) {
      console.error('No token found!')
      setCombatLog(['âŒ Brak tokenu - zaloguj siÄ™ ponownie'])
      setIsFinished(true)
      return
    }

    const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000'
    const eventSource = new EventSource(`${API_URL}/game/combat?token=${encodeURIComponent(token)}`)
    eventSourceRef.current = eventSource

    eventSource.onopen = () => console.log('EventSource connected')
    eventSource.onmessage = (event) => {
      try {
        const data: CombatEvent = JSON.parse(event.data)
        console.log('Received event:', data.type, 'seq:', data.seq)
        setEventQueue(prev => {
          const newQueue = [...prev, data]
          newQueue.sort((a, b) => (a.seq || 0) - (b.seq || 0))
          return newQueue
        })
        if (data.type === 'units_init') setIsPlaying(true)
        if (data.type === 'end') {
          eventSource.close()
          eventSourceRef.current = null
        }
      } catch (err) {
        console.error('Error parsing combat event', err)
      }
    }
    eventSource.onerror = (err) => {
      console.error('EventSource error', err)
      if (eventSource.readyState === EventSource.CLOSED) {
        eventSource.close()
        eventSourceRef.current = null
      }
    }
    return () => {
      eventSource.close()
      eventSourceRef.current = null
    }
  }, []) // Remove token dependency since it shouldn't change during combat

  useEffect(() => {
    if (!isPlaying || eventQueue.length === 0 || processingRef.current) return;

    processingRef.current = true;

    const processNextEvent = () => {
      setEventQueue(prev => {
        if (prev.length === 0) {
          processingRef.current = false;
          return prev;
        }
        const nextEvent = prev[0];
        let rest = prev.slice(1);
        let currentPlayerUnits = [...playerUnitsRef.current]
        let currentOpponentUnits = [...opponentUnitsRef.current]
        console.log('Processing event:', nextEvent.type, 'seq:', nextEvent.seq);
        // Update lastTimestampRef for delay calculation
        let eventTimestamp = typeof nextEvent.timestamp === 'number' ? nextEvent.timestamp : null;
        if (eventTimestamp !== null) lastTimestampRef.current = eventTimestamp;

        if (nextEvent.type === 'start') {
            const msg = 'âš”ï¸ Walka rozpoczyna siÄ™!'
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'units_init') {
            if (nextEvent.player_units) {
              const players = nextEvent.player_units;
              const normalizedPlayers = players.map((u, idx) => ({
                ...u,
                hp: u.hp ?? 0,
                current_mana: u.current_mana ?? 0,
                shield: u.shield ?? 0,
                position: u.position ?? (idx < Math.ceil(players.length / 2) ? 'front' : 'back')
              }));
              currentPlayerUnits = normalizedPlayers
            }
            if (nextEvent.opponent_units) {
              const opponents = nextEvent.opponent_units;
              const normalizedOpps = opponents.map((u, idx) => ({
                ...u,
                hp: u.hp ?? 0,
                current_mana: u.current_mana ?? 0,
                shield: u.shield ?? 0,
                position: u.position ?? (idx < Math.ceil(opponents.length / 2) ? 'front' : 'back')
              }));
              currentOpponentUnits = normalizedOpps
            }
            if (nextEvent.synergies) setSynergies(nextEvent.synergies);
            if (nextEvent.traits) setTraits(nextEvent.traits);
            if (nextEvent.opponent) setOpponentInfo(nextEvent.opponent);
          } else if (nextEvent.type === 'state_snapshot') {
            // Authoritative periodic snapshot from server. Merge into local state
            console.log('Processing state_snapshot', nextEvent.game_state)
            const snapTs = typeof nextEvent.timestamp === 'number' ? nextEvent.timestamp : null
            const snapSeq = (nextEvent as any).seq ?? null
            if (nextEvent.player_units) {
              const players = nextEvent.player_units as any[]
              const normalizedPlayers = players.map((u, idx) => ({
                ...u,
                hp: u.hp ?? 0,
                current_mana: u.current_mana ?? 0,
                shield: u.shield ?? 0,
                position: u.position ?? (idx < Math.ceil(players.length / 2) ? 'front' : 'back')
              }))
              if (overwriteSnapshots) {
                const prevMap = new Map(currentPlayerUnits.map(p => [p.id, p]))
                currentPlayerUnits = normalizedPlayers.map(u => {
                  const prevU = prevMap.get(u.id)
                  // compute field-level diff for DESYNC reporting
                  const diff: Record<string, { ui: any, server: any }> = {}
                  if (prevU) {
                    const fields = ['hp', 'max_hp', 'attack', 'defense', 'current_mana', 'shield']
                    for (const f of fields) {
                      const uiV = (prevU as any)[f]
                      const svV = (u as any)[f]
                      if (uiV !== svV) diff[f] = { ui: uiV, server: svV }
                    }
                    // compare buffed_stats shallow
                    const uiBuff = prevU.buffed_stats || {}
                    const svBuff = u.buffed_stats || {}
                    if (JSON.stringify(uiBuff) !== JSON.stringify(svBuff)) diff['buffed_stats'] = { ui: uiBuff, server: svBuff }

                    if (Object.keys(diff).length > 0) {
                      pushDesync({ unit_id: u.id, unit_name: u.name, seq: snapSeq, timestamp: snapTs, diff, pending_events: rest ? rest.slice(0, 10) : [], note: 'state_snapshot diff (player)' })
                    }
                  }
                  return {
                    ...u,
                    // preserve avatar/template_id/factions/classes/skill from previous UI state when missing in snapshot
                    avatar: prevU?.avatar || (u as any).avatar || undefined,
                    template_id: (prevU as any)?.template_id || (u as any).template_id || undefined,
                    factions: prevU?.factions || (u as any).factions || undefined,
                    classes: prevU?.classes || (u as any).classes || undefined,
                    skill: prevU?.skill || (u as any).skill || undefined,
                  }
                })
              } else {
                // When overwriteSnapshots is false, compute diffs/push desyncs but do not change UI state.
                const prevMap = new Map(currentPlayerUnits.map(p => [p.id, p]))
                for (const u of normalizedPlayers) {
                  const prevU = prevMap.get(u.id)
                  if (!prevU) continue
                  const diff: Record<string, { ui: any, server: any }> = {}
                  const fields = ['hp', 'max_hp', 'attack', 'defense', 'current_mana', 'shield']
                  for (const f of fields) {
                    const uiV = (prevU as any)[f]
                    const svV = (u as any)[f]
                    if (uiV !== svV) diff[f] = { ui: uiV, server: svV }
                  }
                  const uiBuff = prevU.buffed_stats || {}
                  const svBuff = u.buffed_stats || {}
                  if (JSON.stringify(uiBuff) !== JSON.stringify(svBuff)) diff['buffed_stats'] = { ui: uiBuff, server: svBuff }
                  if (Object.keys(diff).length > 0) {
                    pushDesync({ unit_id: u.id, unit_name: u.name, seq: snapSeq, timestamp: snapTs, diff, pending_events: rest ? rest.slice(0, 10) : [], note: 'state_snapshot diff (player, not applied)' })
                  }
                }
                // currentPlayerUnits remains unchanged
              }
              // Always update effects from server, even if overwriteSnapshots is false
              currentPlayerUnits = currentPlayerUnits.map(u => {
                const serverU = normalizedPlayers.find(su => su.id === u.id)
                if (serverU) {
                  return { ...u, effects: serverU.effects }
                }
                return u
              })
            }
            if (nextEvent.opponent_units) {
              const opponents = nextEvent.opponent_units as any[]
              const normalizedOpps = opponents.map((u, idx) => ({
                ...u,
                hp: u.hp ?? 0,
                current_mana: u.current_mana ?? 0,
                shield: u.shield ?? 0,
                position: u.position ?? (idx < Math.ceil(opponents.length / 2) ? 'front' : 'back')
              }))

              if (overwriteSnapshots) {
                const prevMap = new Map(currentOpponentUnits.map(p => [p.id, p]))
                currentOpponentUnits = normalizedOpps.map(u => {
                  const prevU = prevMap.get(u.id)
                  const diff: Record<string, { ui: any, server: any }> = {}
                  if (prevU) {
                    const fields = ['hp', 'max_hp', 'attack', 'defense', 'current_mana', 'shield']
                    for (const f of fields) {
                      const uiV = (prevU as any)[f]
                      const svV = (u as any)[f]
                      if (uiV !== svV) diff[f] = { ui: uiV, server: svV }
                    }
                    const uiBuff = prevU.buffed_stats || {}
                    const svBuff = u.buffed_stats || {}
                    if (JSON.stringify(uiBuff) !== JSON.stringify(svBuff)) diff['buffed_stats'] = { ui: uiBuff, server: svBuff }
                    if (Object.keys(diff).length > 0) {
                      pushDesync({ unit_id: u.id, unit_name: u.name, seq: snapSeq, timestamp: snapTs, diff, pending_events: rest ? rest.slice(0, 10) : [], note: 'state_snapshot diff (opponent)' })
                    }
                  }
                  return {
                    ...u,
                    avatar: prevU?.avatar || (u as any).avatar || undefined,
                    template_id: (prevU as any)?.template_id || (u as any).template_id || undefined,
                    factions: prevU?.factions || (u as any).factions || undefined,
                    classes: prevU?.classes || (u as any).classes || undefined,
                    skill: prevU?.skill || (u as any).skill || undefined,
                  }
                })
              } else {
                const prevMap = new Map(currentOpponentUnits.map(p => [p.id, p]))
                for (const u of normalizedOpps) {
                  const prevU = prevMap.get(u.id)
                  if (!prevU) continue
                  const diff: Record<string, { ui: any, server: any }> = {}
                  const fields = ['hp', 'max_hp', 'attack', 'defense', 'current_mana', 'shield']
                  for (const f of fields) {
                    const uiV = (prevU as any)[f]
                    const svV = (u as any)[f]
                    if (uiV !== svV) diff[f] = { ui: uiV, server: svV }
                  }
                  const uiBuff = prevU.buffed_stats || {}
                  const svBuff = u.buffed_stats || {}
                  if (JSON.stringify(uiBuff) !== JSON.stringify(svBuff)) diff['buffed_stats'] = { ui: uiBuff, server: svBuff }
                  const uiEff = (prevU.effects || []).map((e: any) => ({ id: e.id, type: e.type, stat: e.stat, value: e.value ?? e.amount, duration: e.duration }))
                  const svEff = (u.effects || []).map((e: any) => ({ id: e.id, type: e.type, stat: e.stat, value: e.value ?? e.amount, duration: e.duration }))
                  if (JSON.stringify(uiEff) !== JSON.stringify(svEff)) diff['effects'] = { ui: uiEff, server: svEff }
                  if (Object.keys(diff).length > 0) {
                    pushDesync({ unit_id: u.id, unit_name: u.name, seq: snapSeq, timestamp: snapTs, diff, pending_events: rest ? rest.slice(0, 10) : [], note: 'state_snapshot diff (opponent, not applied)' })
                  }
                }
                // currentOpponentUnits remains unchanged
              }
              // Always update effects from server, even if overwriteSnapshots is false
              currentOpponentUnits = currentOpponentUnits.map(u => {
                const serverU = normalizedOpps.find(su => su.id === u.id)
                if (serverU) {
                  return { ...u, effects: serverU.effects }
                }
                return u
              })
            }
            if (nextEvent.synergies) setSynergies(nextEvent.synergies)
            if (nextEvent.traits) setTraits(nextEvent.traits)
            if (nextEvent.opponent) setOpponentInfo(nextEvent.opponent)

            // Drop queued events that are older than snapshot (by seq if present, else by timestamp)
            if (snapSeq !== null) {
              const filtered = rest.filter(e => {
                const es = (e as any).seq
                if (typeof es === 'number') return es > snapSeq
                if (typeof e.timestamp === 'number' && snapTs !== null) return e.timestamp > snapTs
                return true
              })
              // replace rest with filtered for further processing
              rest = filtered
            } else if (snapTs !== null) {
              const filtered = rest.filter(e => (typeof e.timestamp === 'number' ? e.timestamp > snapTs : true))
              rest = filtered
            }

            if (snapTs !== null) lastTimestampRef.current = snapTs
          }
          else if (nextEvent.type === 'attack') {
            // Update HP and shield immediately on attack
            const targetId = nextEvent.target_id
            const targetHp = nextEvent.target_hp
            const shieldAbsorbed = nextEvent.shield_absorbed || 0
            const side = nextEvent.side
            if (targetId && typeof targetHp === 'number' && side) {
              if (side === 'team_a') {
                currentPlayerUnits = currentPlayerUnits.map(u =>
                  u.id === targetId ? { ...u, hp: targetHp, shield: Math.max(0, (u.shield || 0) - shieldAbsorbed) } : u
                )
              } else {
                currentOpponentUnits = currentOpponentUnits.map(u =>
                  u.id === targetId ? { ...u, hp: targetHp, shield: Math.max(0, (u.shield || 0) - shieldAbsorbed) } : u
                )
              }
            }
          } else if (nextEvent.type === 'unit_attack') {
            if (nextEvent.attacker_id && nextEvent.target_id) {
              const attacker = nextEvent.attacker_id as string
              const target = nextEvent.target_id as string
              // add attacker/target to active lists so animations can overlap
              setAttackingUnits(prev => [...prev, attacker])
              setTargetUnits(prev => [...prev, target])
              setAnimatingUnits(prev => [...prev, attacker, target])
              // compute animation duration based on attacker's attack_speed (attacks per second)
              const allUnits = [...playerUnits, ...opponentUnits]
              const attackerUnit = allUnits.find(u => u.id === attacker)
              const attackerAS = (attackerUnit && attackerUnit.buffed_stats?.attack_speed) || 1
              // avoid division by zero and clamp reasonable values
              const normalizedAS = Math.max(0.1, parseFloat(String(attackerAS)))
              // base interval between attacks in ms = 1000 / attack_speed
              const baseInterval = 1000 / normalizedAS
              const duration = Math.round(Math.max(150, Math.min(3000, baseInterval * animationScale / combatSpeed)))

              // set per-unit durations for UI components to use for CSS animation timings
              setAttackDurations(prev => ({ ...prev, [attacker]: duration, [target]: duration }))

              const id1 = setTimeout(() => { setAttackingUnits(prev => prev.filter(id => id !== attacker)); setAttackDurations(prev => { const copy = { ...prev }; delete copy[attacker]; return copy }) }, duration)
              activeTimeoutsRef.current.push(id1)
              const id2 = setTimeout(() => { setTargetUnits(prev => prev.filter(id => id !== target)); setAttackDurations(prev => { const copy = { ...prev }; delete copy[target]; return copy }) }, duration)
              activeTimeoutsRef.current.push(id2)
              const id3 = setTimeout(() => { setAnimatingUnits(prev => prev.filter(id => id !== attacker && id !== target)) }, duration)
              activeTimeoutsRef.current.push(id3)
            }
            // Accept both unit_hp (preferred) and target_hp (legacy/backend)
            // Accept both unit_hp (preferred) and target_hp (legacy/backend)
            const attackHp = nextEvent.unit_hp !== undefined ? nextEvent.unit_hp : nextEvent.target_hp;
            if (nextEvent.target_id && attackHp !== undefined) {
              if (nextEvent.target_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => {
                  if (u.id !== nextEvent.target_id) return u
                  const newShield = Math.max(0, (u.shield || 0) - (nextEvent.shield_absorbed || 0))
                  return { ...u, hp: attackHp, shield: Math.round(newShield) }
                })
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => {
                  if (u.id !== nextEvent.target_id) return u
                  const newShield = Math.max(0, (u.shield || 0) - (nextEvent.shield_absorbed || 0))
                  return { ...u, hp: attackHp, shield: Math.round(newShield) }
                })
              }
            }
            const msg = nextEvent.is_skill
              ? `ðŸ”¥ ${nextEvent.attacker_name} zadaje ${nextEvent.damage?.toFixed(2)} obraÅ¼eÅ„ ${nextEvent.target_name} (umiejÄ™tnoÅ›Ä‡)`
              : `âš”ï¸ ${nextEvent.attacker_name} atakuje ${nextEvent.target_name} (${(nextEvent.damage ?? 0).toFixed(2)} dmg)`
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'unit_died') {
            // Ensure HP is 0 when unit dies
            if (nextEvent.unit_id) {
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, hp: 0 } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, hp: 0 } : u);
              }
            }
            const msg = `ðŸ’€ ${nextEvent.unit_name} zostaje pokonany!`
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'gold_reward') {
            const msg = `ðŸ’° ${nextEvent.unit_name} daje +${nextEvent.amount} gold (sojusznik umarÅ‚)`
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'stat_buff') {
            //console.log('Received stat_buff event:', nextEvent);
            const statName = nextEvent.stat === 'attack' ? 'Ataku' : nextEvent.stat === 'defense' ? 'Obrony' : nextEvent.stat || 'Statystyki';
            const buffType = nextEvent.buff_type === 'debuff' ? 'â¬‡ï¸' : 'â¬†ï¸';
            let reason = '';
            if (nextEvent.buff_type === 'debuff') {
              reason = '(umiejÄ™tnoÅ›Ä‡)';
            } else if (nextEvent.cause === 'kill') {
              reason = '(zabity wrÃ³g)';
            }
            const msg = `${buffType} ${nextEvent.unit_name} ${nextEvent.buff_type === 'debuff' ? 'traci' : 'zyskuje'} ${nextEvent.amount} ${statName} ${reason}`
            setCombatLog(prev => [...prev, msg]);
            // Update unit buffed_stats in UI
            if (nextEvent.unit_id) {
              const updateUnit = (u: Unit) => {
                if (nextEvent.stat === 'attack') {
                  const amount = nextEvent.amount ?? 0
                  return {
                    ...u,
                    attack: u.attack + amount,
                    buffed_stats: { ...u.buffed_stats, attack: (u.buffed_stats?.attack ?? u.attack) + amount }
                  };
                } else if (nextEvent.stat === 'defense') {
                  const amount = nextEvent.amount ?? 0
                  return {
                    ...u,
                    defense: (u.defense ?? 0) + amount,
                    buffed_stats: { ...u.buffed_stats, defense: (u.buffed_stats?.defense ?? u.defense ?? 0) + amount }
                  };
                }
                return u;
              };
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? updateUnit(u) : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? updateUnit(u) : u);
              }
            }
          } else if (nextEvent.type === 'gold_income') {
            const breakdown = nextEvent as any;
            setStoredGoldBreakdown({ base: breakdown.base || 0, interest: breakdown.interest || 0, milestone: breakdown.milestone || 0, win_bonus: breakdown.win_bonus || 0, total: breakdown.total || 0 });
          } else if (nextEvent.type === 'victory') {
            const msg = 'ðŸŽ‰ ZWYCIÄ˜STWO!'
            setCombatLog(prev => [...prev, msg]);
            setVictory(true);
          } else if (nextEvent.type === 'defeat') {
            const msg = nextEvent.message || 'ðŸ’” PRZEGRANA!'
            setCombatLog(prev => [...prev, msg]);
            setVictory(false);
          } else if (nextEvent.type === 'end') {
            setIsFinished(true);
            if (nextEvent.state) setFinalState(nextEvent.state);
            setIsPlaying(false);
          } else if (nextEvent.type === 'heal') {
            // Update HP immediately on heal
            const unitId = nextEvent.unit_id
            const amount = nextEvent.amount
            const side = nextEvent.side
            if (unitId && typeof amount === 'number' && side) {
              const updateFn = (prev: Unit[]) => prev.map(u =>
                u.id === unitId ? { ...u, hp: Math.min(u.max_hp, u.hp + amount) } : u
              )
              if (side === 'team_a') {
                currentPlayerUnits = currentPlayerUnits.map(u =>
                  u.id === unitId ? { ...u, hp: Math.min(u.max_hp, u.hp + amount) } : u
                )
              } else {
                currentOpponentUnits = currentOpponentUnits.map(u =>
                  u.id === unitId ? { ...u, hp: Math.min(u.max_hp, u.hp + amount) } : u
                )
              }
            }
          } else if (nextEvent.type === 'unit_heal') {
            // Accept both unit_hp (preferred) and target_hp (legacy/backend)
            const healedHp = nextEvent.unit_hp !== undefined ? nextEvent.unit_hp : nextEvent.target_hp;
            if (nextEvent.unit_id && healedHp !== undefined) {
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, hp: healedHp } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, hp: healedHp } : u);
              }
            }
            const msg = `ðŸ’š ${nextEvent.unit_name} regeneruje ${(nextEvent.amount ?? 0).toFixed(2)} HP`
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'damage_over_time_tick') {
            // Update unit HP and log DoT tick
            const tickHp = nextEvent.unit_hp !== undefined ? nextEvent.unit_hp : undefined
            if (nextEvent.unit_id && tickHp !== undefined) {
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, hp: tickHp } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, hp: tickHp } : u);
              }
            }
            const dmg = nextEvent.damage ?? 0
            const msg = `ðŸ”¥ ${nextEvent.unit_name} otrzymuje ${dmg} obraÅ¼eÅ„ (DoT)`
            setCombatLog(prev => [...prev, msg]);
            // small visual flash on target
            if (nextEvent.unit_id) {
              const unitId = nextEvent.unit_id as string
              setTargetUnits(prev => [...prev, unitId])
              const dur = Math.round(600 * animationScale / combatSpeed)
              const id = setTimeout(() => setTargetUnits(prev => prev.filter(id => id !== unitId)), dur)
              activeTimeoutsRef.current.push(id)
            }
          } else if (nextEvent.type === 'regen_gain') {
            if (nextEvent.unit_id) {
              const dur = nextEvent.duration || 5;
              const expiresAt = Date.now() + dur * 1000;
              setRegenMap(prev => ({ ...prev, [nextEvent.unit_id!]: { amount_per_sec: nextEvent.amount_per_sec || 0, total_amount: nextEvent.total_amount || 0, expiresAt } }));
              const msg = `ðŸ’š ${nextEvent.unit_name} zyskuje +${(nextEvent.total_amount || 0).toFixed(2)} HP przez ${dur}s`
              setCombatLog(prev => [...prev, msg]);
            }
          } else if (nextEvent.type === 'mana_update') {
            if (nextEvent.unit_id && nextEvent.current_mana !== undefined) {
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, current_mana: nextEvent.current_mana } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, current_mana: nextEvent.current_mana } : u);
              }
            }
            const msg = `ðŸ”® ${nextEvent.unit_name} mana: ${nextEvent.current_mana}/${nextEvent.max_mana}`
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'skill_cast') {
            console.log('Processing skill_cast event:', nextEvent);
            // Update target HP if damage was dealt
            if (nextEvent.target_id && nextEvent.target_hp !== undefined) {
              if (nextEvent.target_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.target_id ? { ...u, hp: nextEvent.target_hp! } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.target_id ? { ...u, hp: nextEvent.target_hp! } : u);
              }
            }
            const msg = `âœ¨ ${nextEvent.caster_name} uÅ¼ywa ${nextEvent.skill_name}!`
            setCombatLog(prev => [...prev, msg]);
          } else if (nextEvent.type === 'shield_applied') {
            // Update shield immediately
            const unitId = nextEvent.unit_id
            const amount = nextEvent.amount
            if (unitId && typeof amount === 'number') {
              if (unitId.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u =>
                  u.id === unitId ? { ...u, shield: (u.shield || 0) + amount } : u
                )
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u =>
                  u.id === unitId ? { ...u, shield: (u.shield || 0) + amount } : u
                )
              }
            }
            const msg = `ðŸ›¡ï¸ ${nextEvent.unit_name} zyskuje ${nextEvent.amount} tarczy na ${nextEvent.duration}s`
            setCombatLog(prev => [...prev, msg]);
            if (nextEvent.unit_id) {
              const effect: EffectSummary = {
                type: 'shield',
                amount: nextEvent.amount,
                duration: nextEvent.duration,
                caster_name: nextEvent.caster_name,
                expiresAt: nextEvent.duration ? Date.now() + (nextEvent.duration * 1000) : undefined
              }
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, effects: [...(u.effects || []), effect], shield: Math.max(0, (u.shield || 0) + (nextEvent.amount || 0)) } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, effects: [...(u.effects || []), effect], shield: Math.max(0, (u.shield || 0) + (nextEvent.amount || 0)) } : u);
              }
            }
          } else if (nextEvent.type === 'unit_stunned') {
            const msg = `ðŸ˜µ ${nextEvent.unit_name} jest ogÅ‚uszony na ${nextEvent.duration}s`
            setCombatLog(prev => [...prev, msg]);
            if (nextEvent.unit_id) {
              const effect: EffectSummary = {
                type: 'stun',
                duration: nextEvent.duration,
                caster_name: nextEvent.caster_name,
                expiresAt: nextEvent.duration ? Date.now() + (nextEvent.duration * 1000) : undefined
              }
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, effects: [...(u.effects || []), effect] } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, effects: [...(u.effects || []), effect] } : u);
              }
            }
          }

          else if (nextEvent.type === 'damage_over_time_applied') {
            // DoT applied: attach effect summary so UI shows burn/DoT badge
            const msg = `ðŸ”¥ ${nextEvent.unit_name} otrzymuje DoT (${nextEvent.ticks || '?'} ticks)`
            setCombatLog(prev => [...prev, msg]);
            if (nextEvent.unit_id) {
              const effect: EffectSummary = {
                type: 'damage_over_time',
                damage: nextEvent.damage || nextEvent.amount,
                duration: nextEvent.duration,
                ticks: nextEvent.ticks,
                interval: nextEvent.interval,
                caster_name: nextEvent.caster_name,
                expiresAt: nextEvent.duration ? Date.now() + (nextEvent.duration * 1000) : undefined
              }
              if (nextEvent.unit_id.startsWith('opp_')) {
                currentOpponentUnits = currentOpponentUnits.map(u => u.id === nextEvent.unit_id ? { ...u, effects: [...(u.effects || []), effect] } : u);
              } else {
                currentPlayerUnits = currentPlayerUnits.map(u => u.id === nextEvent.unit_id ? { ...u, effects: [...(u.effects || []), effect] } : u);
              }
            }
          }

          setPlayerUnits(currentPlayerUnits)
          setOpponentUnits(currentOpponentUnits)

          console.log('After processing event', nextEvent.type, 'seq:', nextEvent.seq, 'player HP:', currentPlayerUnits.map(u => ({id: u.id, hp: u.hp})))
          console.log('Opponent HP:', currentOpponentUnits.map(u => ({id: u.id, hp: u.hp})))

          if (nextEvent.game_state) {
            compareUnits(currentPlayerUnits, nextEvent.game_state.player_units, 'player', nextEvent)
            compareUnits(currentOpponentUnits, nextEvent.game_state.opponent_units, 'opponent', nextEvent)
          }

          let delay = lastTimestampRef.current === null ? 0 : (500 * animationScale) / combatSpeed;
          if (rest.length > 0) {
            const curr = typeof nextEvent.timestamp === 'number' ? nextEvent.timestamp : null;
            const next = typeof rest[0].timestamp === 'number' ? rest[0].timestamp : null;
            if (curr !== null && next !== null && next > curr) {
              delay = ((next - curr) * 1000) / combatSpeed;
            }
          }
          if (rest.length > 0 && rest[0].type === 'start') {
            delay = 1000 / combatSpeed;
          }
          if (rest.length > 0) {
            setTimeout(processNextEvent, delay);
          } else {
            processingRef.current = false;
          }

          setPlayerUnits(currentPlayerUnits)
          setOpponentUnits(currentOpponentUnits)

          return rest;
        });
      };

      processNextEvent();
    }, [eventQueue, isPlaying, combatSpeed]);

  useEffect(() => {
    const t = setInterval(() => {
      const now = Date.now()
      setRegenMap(prev => {
        const copy = { ...prev }
        let changed = false
        for (const k of Object.keys(copy)) {
          if (copy[k].expiresAt <= now) {
            delete copy[k]
            changed = true
          }
        }
        return changed ? copy : prev
      })

      // Cleanup expired effects on units
      setPlayerUnits(prev => {
        let changed = false
        const next = prev.map(u => {
          if (!u.effects || u.effects.length === 0) return u
          const remaining = u.effects.filter((e: EffectSummary) => !e.expiresAt || e.expiresAt > now)
          if (remaining.length !== u.effects.length) {
            changed = true
            // Compute removed effects to adjust numeric shields if needed
            const removed = u.effects.filter((e: EffectSummary) => !(remaining.includes(e)))
            let newShield = u.shield || 0
            // Note: Shield effects are for UI badges only; numeric shield is source of truth and not adjusted here
            return { ...u, effects: remaining, shield: Math.round(newShield) }
          }
          return u
        })
        return changed ? next : prev
      })

      setOpponentUnits(prev => {
        let changed = false
        const next = prev.map(u => {
          if (!u.effects || u.effects.length === 0) return u
          const remaining = u.effects.filter((e: EffectSummary) => !e.expiresAt || e.expiresAt > now)
          if (remaining.length !== u.effects.length) {
            changed = true
            // Note: Shield effects are for UI badges only; numeric shield is source of truth and not adjusted here
            return { ...u, effects: remaining, shield: Math.round(u.shield || 0) }
          }
          return u
        })
        return changed ? next : prev
      })
    }, 500)
    return () => clearInterval(t)
  }, [])

  useEffect(() => { logEndRef.current?.scrollIntoView({ behavior: 'smooth' }) }, [combatLog])

  const handleClose = () => onClose(finalState || undefined)
  const handleGoldDismiss = () => { setDisplayedGoldBreakdown(null); setStoredGoldBreakdown(null); handleClose() }

  // Cleanup active timeouts on unmount or end
  useEffect(() => {
    return () => {
      activeTimeoutsRef.current.forEach(id => clearTimeout(id))
      activeTimeoutsRef.current = []
    }
  }, [])

  return {
    playerUnits,
    opponentUnits,
    combatLog,
    isFinished,
    victory,
    finalState,
    synergies,
    traits,
    hoveredTrait,
    setHoveredTrait,
    opponentInfo,
    showLog,
    setShowLog,
    attackingUnits,
    targetUnits,
    attackDurations,
    animatingUnits,
    combatSpeed,
    setCombatSpeed,
    regenMap,
    storedGoldBreakdown,
    displayedGoldBreakdown,
    setDisplayedGoldBreakdown,
    setStoredGoldBreakdown,
    handleClose,
    handleGoldDismiss
    ,
    desyncLogs,
    clearDesyncLogs,
    exportDesyncJSON
    ,
    overwriteSnapshots,
    setOverwriteSnapshots
  }
}
